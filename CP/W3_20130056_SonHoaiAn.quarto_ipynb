{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Initial-Value Problems for ODEs\n",
        "\n",
        "## Euler's method\n",
        "\n",
        "1. Theory \\\n",
        "    This method gives us the way to calculate the integral of a function on an interval A = [a, b] by sum of all values of the function at each points on the interval. The points must be satisfied the distance between each points and insider the interval.\n",
        "\n",
        "2. Algorithms \\\n",
        "\n",
        "\n",
        "        ```{text}\n",
        "        FUNCTION EulerMethod(f, lower, upper, y0, step ):\n",
        "            # set value to function processing\n",
        "            x = lower\n",
        "\n",
        "            # value of a function at an initial point\n",
        "            y = y0\n",
        "            \n",
        "            # calculate length of step\n",
        "            step_len = abs(upper - lower)/step\n",
        "\n",
        "            # Loop over the number of steps\n",
        "            FOR i FROM 0 TO n-1 DO:\n",
        "                # Update y using Euler's formula\n",
        "                y = y + step_len * f(x, y)\n",
        "                \n",
        "                # Update x\n",
        "                x = x + step_len\n",
        "\n",
        "            #return the result of y\n",
        "        RETURN y \n",
        "        ```\n",
        "\n",
        "    \n",
        "    If you want to return the series of results, you can modify the  function  above to get them all\n",
        "\n",
        "3. Practice \n"
      ],
      "id": "d2429516"
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": "    "
      },
      "source": [
        "def EulerMethod(func, lower, upper, seed, step):\n",
        "    x = lower\n",
        "    y = seed\n",
        "\n",
        "    # length of step\n",
        "    step_len = abs(lower - upper)/step\n",
        "\n",
        "    # Loop and take sum of function values\n",
        "    for i in range(step):\n",
        "        # update the result\n",
        "        y = y + step_len*func(x, y)\n",
        "\n",
        "        # re-assign x\n",
        "        x += step_len\n",
        "\n",
        "    return y"
      ],
      "id": "a2d49a89",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "4. Trials run \n",
        "\n",
        "    We will try to evaluate the function $f(x) =  x^2 + 5$ on the interval **[2, 4]** with 50 steps\n"
      ],
      "id": "121dc727"
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": "    "
      },
      "source": [
        "def EulerMethod(func, seed, lower, upper, step):\n",
        "    x = lower\n",
        "    y = seed\n",
        "\n",
        "    # Loop and take sum of function values\n",
        "    while x <= upper:\n",
        "        # update the result\n",
        "        y = y + step*func(x)\n",
        "\n",
        "        # re-assign x\n",
        "        x = x + step\n",
        "\n",
        "    return y\n",
        "\n",
        "f = lambda x: x**2 + 5\n",
        "a = 2\n",
        "b = 4\n",
        "stp = 0.001\n",
        "int_val = 0.0\n",
        "\n",
        "res = EulerMethod(f, int_val, a, b, stp)\n",
        "\n",
        "print(f\"The result of f(x) = x^2 + 5 is {res: 5.5f}\")"
      ],
      "id": "6e6bf320",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "    For this code above for the function $f(x) = x^2 + 5$, the program will be calculate the sum of function $f(x)$ from 2 to 4 with the initial value of zero (0)\n",
        "## Higher - Order Taylor Methods\n",
        "\n",
        "1. Theory \\\n",
        "\n",
        "    The Higher - order Taylor method is a nummerical method which is used to solve ODE by using approximation solutions based on Taylor's series. This method can provide better results and more accuracy when comparing to the lower - order methods as the Euler's method and its variations, etc. \n",
        "\n",
        "2. Algorithms \\\n",
        "\n",
        "    When using this method, we need to use the corresponding higher order of derivatives. In the psuedo below, we will try to see the second order Taylor method.\n",
        "\n",
        "\n",
        "    ```{pseudo}\n",
        "    FUNCTION f(x)\n",
        "\n",
        "    FUNCTION f_second_diff(x)\n",
        "        RETURN DIFF(f(x))\n",
        "\n",
        "    FUNCTION taylor_2nd(func, initial_val, lower, upper, step_len):\n",
        "        \n",
        "        ASSIGN:\n",
        "            x = lover\n",
        "            h = step_len\n",
        "            y = initial_val\n",
        "\n",
        "\n",
        "        DO:\n",
        "            y = y + h*f(x) + (h^2/2)*f_second_diff(f(x))\n",
        "            x += h\n",
        "        WHILE(x <= upper)\n",
        "        \n",
        "    DISPLAY:\n",
        "        PRINT(\"The integration of the function y' = f(x) on the interval [lower, upper] is \"y)\n",
        "    ```\n",
        "\n",
        "\n",
        "    $\\hspace{10pt}$ In the algorithms above, the function will be calculate the second derivate of y via y' = f(x) then doing the calulation of the Taylor series over and over in the inteval of [a, b] to get the result of an integration of y'\n",
        "\n",
        "3. Practice \\"
      ],
      "id": "de63ed4b"
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": "    "
      },
      "source": [
        "import sympy as sp\n",
        "\n",
        "# declare function\n",
        "x = sp.symbols('x')\n",
        "f = x**2 + 5\n",
        "\n",
        "f_prime = sp.diff(x, f)\n",
        "\n",
        "# declare variable for calculation\n",
        "a = 2\n",
        "b = 4\n",
        "step_len = 0.1\n",
        "y = 0 # initial value\n",
        "\n",
        "# Higher Order methods Function (2nd order)\n",
        "def Taylor2ndOrder(func, initial_val, lower, upper, distance):\n",
        "    x = lower\n",
        "    f_prime = sp.diff(x, func)\n",
        "    y = initial_val\n",
        "\n",
        "    while (x < upper):\n",
        "        y = y + distance*func(x) + (distance**2/2)*f_prime(x)\n",
        "        x += distance"
      ],
      "id": "47ba6093",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Runge - Kutta Methods\n",
        "\n",
        "### Runggu - Kuta 1\n",
        "### Euler Enhanced Metho-\n",
        "### Rungu - Kuta 2\n",
        "### Rungu - Kuta 3\n",
        "### Rungu - Kuta 4"
      ],
      "id": "b5ff728b"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Program Files\\Python\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}